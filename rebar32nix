#!/usr/bin/env escript

main(Args) ->
  case main(Args, []) of
    {ok, State} ->
      LockFile = resolve_lockfile(proplists:get_value(dir, State)),
      {ok, Terms} = file:consult(LockFile),
      io:put_chars(nix_derivation(Terms));
    {error, Reason} ->
      io:format("Error: ~s~n", [Reason]),
      halt(1)
  end.

main([], State) ->
  {ok, State};
main(["--dir", Dir | Rest], State) ->
  main(Rest, [{dir, Dir} | State]);
main([Arg | _Rest], _State) ->
  io:put_chars(standard_error, "Usage: rebar32nix [--dir DIR]\n"),
  {error, io_lib:format("Unknown argument: ~s", [Arg])}.

resolve_lockfile(undefined) ->
  {ok, Cwd} = file:get_cwd(),
  filename:join(Cwd, "rebar.lock");
resolve_lockfile(Dir) ->
  filename:join(Dir, "rebar.lock").

nix_derivation(Lock) ->
  io_lib:format(<<"
{ stdenv, rebar3, writeShellScriptBin }:

with stdenv.lib;

let
  closure = ~s;

  fakeGit = writeShellScriptBin ''git'' ''cat rev || true'';

  linkPackage = name: src: ''
    mkdir -p _build/default/lib/${name}/ebin
    cp -rs ${src}/. $_/..
    echo ${src.rev} > $_/rev
  '';
in

stdenv.mkDerivation {
  name = ''rebar3-release'';
  src = ./.;

  buildInputs = [ fakeGit rebar3 ];

  configurePhase = concatStrings (mapAttrsToList linkPackage closure);
  buildPhase = ''rebar3 release --dev-mode false --include-erts false'';
  installPhase = ''mv _build/default/rel/* $out'';
}
">>, [rebar3_closure(Lock)]).

rebar3_closure([Pkgs]) ->
    Props = lists:map(fun({PName, Meta, Num}) -> {PName, {Meta, Num}} end, Pkgs),
    Names = proplists:get_keys(Props),
    Tuples = lists:map(fun(Name) -> {Name, proplists:get_value(Name, Props)} end, Names),
    ["{", lists:concat(lists:map(fun(X) -> to_fetch(X) end, Tuples)), "}"].

to_fetch({Name, {{git, Url, {ref, Ref}}, _N}}) ->
  io_lib:format("
  \"~s\" = builtins.fetchGit {
    url = \"~s\";
    rev = \"~s\";
  };
", [Name, Url, Ref]).
